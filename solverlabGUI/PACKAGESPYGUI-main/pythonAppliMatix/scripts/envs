#!/usr/bin/env python
#-*- coding:utf-8 -*-

__doc__="""

%s

List all or specific environment variables

1- split all or specific environment variables $XXX(s)...
   example: 
   >> environs.py -> all
   >> environs.py -e SHELL,PATH -> specific $SHELL and $PATH

2- split all or specific environment variables on pattern $*XXX*(s)...
   example: 
   >> environs.py --pattern ROOT -> specific $*ROOT*
 
3- split search specific substrings in contents of environment variables $XXX(s)...
   example: 
   >> environs.py --grep usr  -> all specific environment variables containing 'usr'

tips
  # create unix alias as shortcut:
  >> alias envs="~/environs.py"
  
  # use for tricky test search string in environment variables in bash script
  >> ./envs && echo ok || echo ko
  >> ./envs -p PATH -g sbin && echo ok || echo ko
  >> ./envs -p xxPATH    # ko
  >> [ $? ] && echo ok || echo ko
  
  # create a saving setenv environment
  envs --create_setenv="${HOME}/my_setenv.tmp"
  # modify environment
  export A_NEW="what a doll"
  # create as diff setenv environment
  envs --create_diff_setenv="${HOME}/my_setenv.tmp"
  cat ${HOME}/my_setenv_diff.tmp

""" % __file__

import os
import sys
import argparse as ARG
import pprint as PP # pretty print

import fnmatch


debug = False
_OK = 0  # bash success
_KO = 1  # bash error

# avoid trickies
_exclude = "BASH_FUNC_* LESSOPEN PS1 _* WINDOWID DISPLAY COLORTERM OLDPWD".split()

def pf_env(environ):
  return PP.pformat(list(environ.keys()))

def printOneLineOrNot(i, options):
  env = options.environ
  splitenv = env[i].split(":")
  done = False
  for j in splitenv:
    if j != "":
      if not done: 
        if not options.quiet: print("{:<30} = {}".format(i, j))
        done = True
      else:
        if not options.detailed:
          if not options.quiet: print("{:<30}   {}".format(" ", j))
        else:
          if not options.quiet: print("{:<30}   {}".format(" ... "+i, j))

def print_split_environs(options):
  env = options.environ
  args = options.envvar.split(",")
  res = False
  if debug: print("print_split_environs %s\n%s" % (args, pf_env(env)))
  for i in sorted(env.keys()):
      if is_in(i, _exclude): continue
      if (args == ['']) or (i in args):
        printOneLineOrNot(i, options)
        res = True
  return res

def print_split_pattern_environs(options):
  env = options.environ
  args = options.pattern.split(",")
  for i in sorted(env.keys()):
      if is_in(i, _exclude): continue
      ok = False
      for j in args:
        if j in i:
          ok = True
          # print("i %s j %s %s" % (i,j,ok))
      if (args == ['']) or (ok):
        printOneLineOrNot(i, options)

def print_grep_environs(options):
  env = options.environ
  args = options.grep.split(",")
  res = False
  for i in sorted(env.keys()):
      if is_in(i, _exclude): continue
      for j in env[i].split(":"):
        for a in args:
          if a in j:
            # print i+" contains  "+j
            if not options.quiet: print("{:<20}    contains '{}' as '{}'".format(i, a, j))
            res = True
  return res


def filter_envvar(envvar, environ):
  res = {}
  args = envvar.split(",")
  if debug: print("args %s" % args)
  if args == []:
    return environ
  for i in sorted(environ):
    ok = False
    for j in args:
      if j == i:
        ok = True
        # print("i %s j %s %s" % (i,j,ok))
      if (len(args) == 0) or (ok):
        res[i] = environ[i]
  if debug: print("filter_envvar res\n%s" % pf_env(res))
  return res


def filter_pattern(pattern, environ):
  res = {}
  args = pattern.split(",")
  if debug: print("args %s" % args)
  if args == []:
    return environ
  for i in sorted(environ.keys()):
    ok = False
    for j in args:
      if j in i:
        ok = True
        # print("i %s j %s %s" % (i,j,ok))
      if (len(args) == 0) or (ok):
        res[i] = environ[i]
  if debug: print("filter_pattern res\n%s" % pf_env(res))
  return res


def is_in(i, exclude):
  for j in exclude:
    match = fnmatch.fnmatchcase(i, j)
    # print(" !!!! is_in %s = %s %s" % (i, j, ok))
    if match: return True
  return False


def create_setenv(options):
  env = options.environ
  args = options.grep.split(",")
  res = False
  tagged = set()
  for i in sorted(env.keys()):
    if is_in(i, _exclude): continue
    for j in env[i].split(":"):
      for a in args:
        if a in j:
          # print i+" contains  "+j
          # if not options.quiet: print("{:<20}    contains '{}' as '{}'".format(i, a, j))
          tagged.add(i)
          res = True # found one with grep ok

  # print("tagged:\n%s" % PP.pformat(tagged))

  namefile = os.path.expandvars(options.create_setenv)

  print("create_setenv file %s" % namefile)
  # print("create_setenv exclude %s" % exclude)

  with open(namefile, "w") as f:
    f.write("""#!/usr/bin/env bash

# This script is a automatic setenv file %s
# created by %s

""" % (namefile, __file__))
    if len(tagged) <= 0:
      f.write("# no env var with --grep=%s" % options.grep)
    else:
      for i in sorted(tagged):
        envi=env[i]
        if " " in envi:
          f.write("""%s='%s'\n""" % (i, envi))
        else:
          f.write("%s=%s\n" % (i, env[i]))
  return res


def read_setenv_file(filename):
  res = {}
  if not os.path.isfile(filename):
    print("ERROR: read_setenv_file inexisting file '%s'" % filename)
    return None
  with open(filename,"r") as f:
    for line in f.readlines():
      line = line.strip()
      if line == "": continue
      if line.startswith("#"): continue
      try:
        key, value = line.split('=', maxsplit=1)
        res[key] = value
      except:
        print("ERROR: read_setenv_file problem at line: '%s'" % line)
  return res

def set_cotes(value):
  # if environ value contains blanks
  if " " in value and not value.startswith("'"):
    return "'" + value + "'"
  return value

def create_diff_setenv(options):
  # debug = True
  env_one = read_setenv_file(options.create_diff_setenv)
  one_keys = sorted(env_one.keys())
  env_two = options.environ
  two_keys = sorted(env_two.keys())
  args = options.grep.split(",")
  res = False
  tagged = set()

  for i in two_keys:
    if is_in(i, _exclude): continue
    if i not in one_keys:
      if debug: print("  key %s is new ->'%s'" % (i, env_two[i]))
      tagged.add(i)
      continue
    value_two = set_cotes(env_two[i])
    if is_in(i, one_keys) and (env_one[i] == value_two): continue
    # if i not in
    if debug: print("  key %s '%s'->'%s'" % (i, env_one[i], value_two))
    tagged.add(i)
    """
      if env_one[i] == env_two[i]
        for j in env_two[i].split(":"):
          for a in args:
            if a in j:
              # print i+" contains  "+j
              # if not options.quiet: print("{:<20}    contains '{}' as '{}'".format(i, a, j))
              tagged.add(i)
              res = True"""

  tagged_unset = set()
  for i in one_keys:
    if is_in(i, _exclude): continue
    if not is_in(i, two_keys):
      if debug: print("  key %s is unset '%s'->None" % (i, env_one[i]))
      tagged_unset.add(i)

  # print("environ vars tagged as unset: %s" % PP.pformat(tagged_unset))
  # print("environ vars tagged as different: %s" % PP.pformat(tagged))

  if options.outfile == "":
    namefile = os.path.expandvars(options.create_diff_setenv)
    adir, afile_ext = os.path.split(namefile)
    afile, aext = os.path.splitext(afile_ext)
    namefile = os.path.join(adir, afile + "_diff" + aext)
  else:
    namefile = options.outfile

  print("create_diff_setenv file %s" % namefile)
  # print("create_diff_setenv exclude %s" % _exclude)

  with open(namefile, "w") as f:
    f.write("""#!/usr/bin/env bash

# This script is a automatic difference setenv file 
# from initial setenv file %s
# created by %s

""" % (options.create_diff_setenv, __file__))

    for i in sorted(tagged_unset):
      f.write("unset %s\n" % i)

    f.write("#\n")

    for i in sorted(tagged):
      f.write("%s=%s\n" % (i, set_cotes(env_two[i])))
  return res




def main(args):
  parser = ARG.ArgumentParser(usage=__doc__) # is top docstring of file
  parser.add_argument("-e", "--envvar", metavar="ENV_VAR", default="", help="example: -e PATH")
  parser.add_argument("-g", "--grep", metavar="GREP_VAR", default="", help="example: -g /home/")
  parser.add_argument("-p", "--pattern", metavar="PATTERN", default="", help="example: -p ROOT")

  parser.add_argument("-q", "--quiet", action="store_true", default=False, help="no-print mode")
  parser.add_argument("-v", "--verbose", action="store_true", default=False, help="debug verbose mode")
  parser.add_argument("-d", "--detailed", action="store_true", default=False, help="detailed display")

  parser.add_argument("--create_setenv", metavar="FILENAME", default="", help="create file setenv from current environment")
  parser.add_argument("--create_diff_setenv", metavar="FILENAME", default="", help="create file setenv as difference from previously created environment")
  parser.add_argument("--outfile", metavar="FILENAME", default="", help="diff_setenv name file output")


  options = parser.parse_args(args)
  if options.verbose: print("Arguments are %s\n" % PP.pformat(options.__dict__))
  options.environ = dict(os.environ)  # copy instance
  
  if debug: print("initial environ is\n%s\n" % pf_env(options.environ.keys()))

  if options.create_setenv != "":
    ok = create_setenv(options)
    return ok

  if options.create_diff_setenv != "":
    ok = create_diff_setenv(options)
    return ok

  ok = False
  if options.pattern != "":
    options.environ = filter_pattern(options.pattern, options.environ)
    ok = (options.environ != {})
    if not ok:
      print("No env_var name with any '%s'" % options.pattern)
      return ok
    # else do options.envvar

  if options.grep != "":
    if options.envvar != "":
      options.environ = filter_envvar(options.envvar, options.environ)
    ok = print_grep_environs(options)
    if not ok:
      print("No env_var with any '%s' in value" % options.grep)
    return ok

  #if options.envvar != "":
  if True:  # do list all if I am here
    ok = print_split_environs(options)
    if not ok:
      print("No env_var name '%s'" % options.envvar)
    return ok



if __name__ == '__main__':
  ok = main(sys.argv[1:])
  if ok:
    sys.exit(_OK)
  else:
    sys.exit(_KO)


