#!/usr/bin/env python
# -*- coding: utf-8 -*-

# %% LICENSE_SALOME_CEA_BEGIN
# see PACKAGESPY/LICENCE file
# %% LICENSE_END


"""\
USAGE:
  AllDistutilsCreatePackage.py
    - create all packages existing with a setup.py file in a root name package
"""


#and so...

import unittest
import glob
import os
import sys
import fnmatch
import subprocess

verbose = False

_strSetup = """\
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# %% LICENSE_SALOME_CEA_BEGIN
# see PACKAGESPY/LICENCE file
# %% LICENSE_END


####################################################
#
################# WARNING ##########################
#
# this file is generated by setupAll.py
# and could be overriden at any time ...
#
####################################################

from distutils.core import setup
import os
from os.path import isfile, join


verbose = True
directory, name = os.path.split( os.path.realpath( __file__ ) )
if os.getcwd() != directory:
  raise Exception("ERROR: '%s' have to be launch in current directory '%s'" % (name, directory))
if name != "setup.py":
  raise Exception("ERROR: '%s' have to be launch as renamed 'setup.py'" % (name))
listDir = [x[0] for x in os.walk("$PACKAGENAME")] #have to be relative

dictFile = dict( ( k, [ f for f in os.listdir(k) if isfile(join(k,f)) ] ) for k in listDir)

if verbose:
  for i in listDir: print "package for dirs:", i
  print "package for files:", dictFile

setup(
      name ='$PACKAGENAME', # Application name
      version = '1.0',
      description = 'Python package pythonAppliMatix $PACKAGENAME',
      license = os.path.join("..", "LICENSE.txt"),
      #long_description = open(os.path.join(directory, "README.txt")).read(),
      long_description = "subpackage $PACKAGENAME of pythonAppliMatix",
      author = 'Christian Van Wambeke',
      author_email = 'christian.van-wambeke@cea.fr',
      packages = listDir,
      package_data = dictFile, #to keep all files .sh etc...
      # Dependent packages (distributions)
      install_requires = [ "numpy" ], #example
      )
"""

def locateDir(pattern, root=os.curdir):
  """
  Locate all directories matching supplied pattern in
  supplied root directory.
  """
  res = [ f for f in os.listdir(root) if os.path.isdir(os.path.join(root,f))]
  return fnmatch.filter(res, pattern)

def multipleReplace(text, wordDict):
  for key in wordDict:
    text = text.replace(key, wordDict[key])
  return text  

def run():
  targetDir = "/tmp/dist"
  directory, name = os.path.split( os.path.realpath( __file__ ) )
  dirsTestPattern = "*py"
  dirs = locateDir(dirsTestPattern, directory)
 
  if len(dirs) == 0:
    mess = "Cannot get dirs '%s' in directory '%s'" % (dirstPattern, directory)
    print("ERROR: " + mess)
    return False

  if verbose: print(dirs)

  for aDir in dirs:
    #create setup.py
    print("#### create setup.py for", aDir)
    keys = {"$PACKAGENAME": aDir}
    aStr = multipleReplace(_strSetup, keys)
    if verbose: print("create setup.py:\n",aStr)
    with open("setup.py", "w") as f: f.write( aStr )
    cmd = "cd %s ; echo 'create package for %s' ; python setup.py sdist --dist-dir %s" % (directory, aDir, targetDir)
    if verbose: print("run command:\n",cmd)
    subprocess.Popen(cmd, shell=True).communicate()
  #print "files in %s:\n" % targetDir, os.listdir(targetDir)
  subprocess.Popen("ls -alt %s" % targetDir, shell=True).communicate()
  return True #ok


if __name__ == '__main__':
  run()

